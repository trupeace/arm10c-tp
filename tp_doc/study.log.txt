
-------------------------------------------------------------------------------
20131102

map_lowmem
memblock.memory.region[0] base=0x20000000 size=0x80000000
  arm_lowmem_limit=0x6f800000
  -> end=0x6f800000, length=0x4f800000

20008000설에 대하여
몇가지 비약이 있다.
반론은 아래와 같다.
1. kernel의 물리주소: 
  2가지로 결정된다. (arch/arm/boot/compressed/head.S 참조)
  CONFIG_AUTO_ZRELADDR 설정시 (current_PC&0xf800_0000)+0x8000
  아닌 경우 Makefile.boot의 zreladdr
  CONFIG_AUTO_ZRELADDR의 경우 bootloader에 의해 결정된다. bootloader는 제맘이다.
  zreladdr의 경우 arch/arm/mach-exynos/Makefile.boot에서 0x40008000으로 설정한다.

2. 커널 entry point와 메모리간 관계
  그러나 지금의 분석대로라면 다음 둘중 하나의 제약이 있어야한다.
  1. kernel image는 메모리의 가장앞에서 0x8000 offset에만 위치하여야 한다.
  2. dtb의 memory노드는 kernel image 이전의 메모리를 가질 수 없다.
  현재까지는 1 또는 2의 제약을 찾지 못했다.
  상식적으로 위의 제약을 만들만한 이유가 없다.


자 설령 0x20008000 approach가 맞다고 가정하겠습니다.


map_lowmem은 정확히 분석해보면
  if (md->virtual != vectors_base() && md->virtual < TASK_SIZE)
    이 조건문은 user_space(TASK_SIZE)를 create_mapping()하면 코드 BUG라는 얘기다.(예외: vector_base가 0번지인 경우 해당 vector는 할당 가능)
  위치 하는 경우_
  if ((md->type == MT_DEVICE || md->type == MT_ROM) && md->virtual >= PAGE_OFFSET &&
                    (md->virtual < VMALLOC_START || md->virtual >= VMALLOC_END)) {
    이 조건문은 DEVICE나 ROM type에 대하여 VMALLOC영역 또는 MODULE영역(TASK_SIZE-PAGE_OFFSET) 이외의 영역을 mapping 시도하면 코드 BUG라는 얘기다.
정리하면 
  USER_SPACE mapping용으로 사용할 수 없다.
  MT_DEVICE,MT_ROM는 VMALLOC 또는 MODULE에만 mapping할 수 있다.

지금부터 알아봐야할 부분은 다음과 같다.
1. memblock을 쪼개 주거나 vmalloc용으로 변경하는 부분이 있는지
2. map_lowmem은 진짜로 무시되어 넘어가고 나중에 
(bank를 


-------------------------------------------------------------------------------
20131026
1. arm_memblock_init() diagram
mdesc>reserve()에서 MFC는 exynos5250에서 존재 5420은 없음
//arch/arm/mach-exynos/mach-exynos5-dt.c 
#ifdef CONFIG_S5P_DEV_MFC
        struct s5p_mfc_dt_meminfo mfc_mem;

        /* Reserve memory for MFC only if it's available */
        mfc_mem.compatible = "samsung,mfc-v6";
        if (of_scan_flat_dt(s5p_fdt_find_mfc_mem, &mfc_mem))
                s5p_mfc_reserve_mem(mfc_mem.roff, mfc_mem.rsize, mfc_mem.loff,
                                mfc_mem.lsize);
#endif

//arch/arm/mach-exynos/Kconfig
config SOC_EXYNOS5250
        bool "SAMSUNG EXYNOS5250"
        default y
        depends on ARCH_EXYNOS5
        select PINCTRL_EXYNOS
        select PM_GENERIC_DOMAINS if PM
        select S5P_PM if PM
        select S5P_SLEEP if PM
        select S5P_DEV_MFC
        select SAMSUNG_DMADEV
        help
          Enable EXYNOS5250 SoC support

//arch/arm/boot/dts/exynos5250.dtsi
        codec@11000000 {
                compatible = "samsung,mfc-v6";
                reg = <0x11000000 0x10000>;
                interrupts = <0 96 0>;
                samsung,power-domain = <&pd_mfc>;
        };


3. .bss에 할당
구조체중 일부분이 초기화되었으므로 .bss는 아니고 .data이며
부분만 초기화된 global variable의 나머지 멤버는 0임 (C99 Standard 6.7.8.21)
19주차 4-3)

4. repeat: 구문은 memblock을
정렬의 이유: 관리(탐색) 목적
memblock_is_memory(), memblock_is_reserved(), memblock_is_region_memory() 등에서 사용하는 memblock_search()함수의 경우 address로 해당 memblock search
정렬되어 있지않은 경우 full search로 인한 연산 낭비 발생

5. memblock_add_region 추가 사례
reserved 영역을 추가하는 경우 address순서로 들어오지 않음
예(kernel: 0xc0008000, page: 0xc0004000) 
hotswap 예: ./arch/powerpc/platforms/pseries/hotplug-memory.c에서 memblock_add등을 호출하고 있음
스터디 시간에는 overlapping case를 hotswap memory 증/감설에 따른 사례로 설명하였으나 reserved에 의한 추가 사례로도 설명 가능
예 (module(memA)와 특정 버퍼(memB)이 있으며 둘다 reserved에 추가하고 서로 포함 관계인 경우 (memA includes memB)
memB가 reserved인 상태에서 memblock_add_region(reserved, memA)시 overlapping condition 동작


6.__init_memblock section
ARM에서는 .meminit.text가 init섹션이 맞다. 
하지만 ARM에서는 ARCH_DISCARD_MEMBLOCK가 config되지 않아 일반 section에 잡힌다.

#ifdef CONFIG_ARCH_DISCARD_MEMBLOCK
#define __init_memblock __meminit
#define __initdata_memblock __meminitdata
#else
#define __init_memblock
#define __initdata_memblock
#endif

//include/linux/init.h
/* Used for MEMORY_HOTPLUG */
#define __meminit        __section(.meminit.text) __cold notrace
#define __meminitdata    __section(.meminit.data)

참고로 
위의 코드에서 memory hotplug시 사용될 수 있음을 유추할 수 있다.
참고로 MEMORY_HOTPLUG는 mm/Kconfig를 살펴보면 현재 일반적인 ARM시스템에서는 사용하지 않으나 X86, PPC등의 SPARSEMEM/NUMA system에서 hotplug시 config된다.


6. 메모리 동적 변경
memory hot plugin
----------------------------------------------------------------
|  memory slot#  |  address     | 변경전적재 | -> | 변경전적재 |
----------------------------------------------------------------
|  memory slot1  |  0x80000000  |     O      | -> |     O      |
|  memory slot2  |  0x90000000  |     X      | -> |     X      |
|  memory slot3  |  0xA0000000  |     O      | -> |     O      |
|  memory slot4  |  0xB0000000  |     X      | -> |     X      |
----------------------------------------------------------------

----------------------------------------------
|  memory slot#  |  address     |  적재여부  |
----------------------------------------------
|  memory slot1  |  0x80000000  |     O      |
|  memory slot2  |  0x90000000  |     O      |
|  memory slot3  |  0xA0000000  |     O      |
|  memory slot4  |  0xB0000000  |     X      |
----------------------------------------------
위와 같이 slot 추가 가능
또는 
---------------------------------------------------------------------------------------------------
|  memory slot#  |  address     | 변경전적재 |             | -> | 변경후적재 |                    |  
---------------------------------------------------------------------------------------------------
|  memory slot1  |  0x80000000  |  O(256MB)  |  region[0]  | -> |  O(512MB)  |  region[0]         |
|  memory slot2  |  0xA0000000  |  O(256MB)  |  region[1]  | -> |  O(256MB)  |  region[0], merged |
---------------------------------------------------------------------------------------------------

----------------------------------------------
|  memory slot#  |  address     |  적재여부  |
----------------------------------------------
|  memory slot1  |  0x80000000  |  O(512MB)  |  region[0]
|  memory slot2  |  0xA0000000  |  O(256MB)  |  region[0], merged
----------------------------------------------

12)
dtb의 reserve_map
예) video/audio accelerator가 DDR의 특정 영역을 buffer로 사용하는 경우 
reserve로 설정
dts에서 root node밖에 "/memreserve/ 64b_addr, 64b_val;"의 문법으로 설정.
다음은 arch/arm/boot/dts/exynos5440-sd5v1.dts에 0x2000_0000~0x2000_00ff의 256B를 reserved로 설정해본 예이다.

/* arch/arm/boot/dts/exynos5440-sd5v1.dts */
/dts-v1/;
/memreserve/ 0x20000000 0x00000100;
/include/ "exynos5440.dtsi"
/ {

// dtb head dump 결과
00000000  d0 0d fe ed 00 00 10 d1  00 00 00 48 00 00 0f 50  |...........H...P|
00000010  00 00 00 28 00 00 00 11  00 00 00 10 00 00 00 00  |...(............|
00000020  00 00 01 81 00 00 0f 08  00 00 00 00 20 00 00 00  |............ ...|
00000030  00 00 00 00 00 00 01 00  00 00 00 00 00 00 00 00  |................|
00000040  00 00 00 00 00 00 00 00  00 00 00 01 00 00 00 00  |................|
00000050  00 00 00 03 00 00 00 04  00 00 00 00 00 00 00 01  |................|




2-1) CR_XP
armv7용 AARM(DDI0406)이 아닌 다른 아키텍처 버전용을 AARM(DDI0100)을 참조하라
요지는 다음과 같다.
ARMv4/v5의 경우 1개 page를 4개 subpage로 나누어(64kB->16kB 또는 4kB->1kB) Access Permission 부여하는 기능을 지원
ARMv6이상부터는 MPCore 등장에 따라 global, shared 구분 및 supersection 등을 도입하고 이를 extended page(XP=1)로 명명
ARMv7은 subpage 기능을 삭제함에 따라 XP=1만 지원하고 이에 따라 해당 bit는 reserved

2-2) cr_alignment val 

reserved_value: 0x00c50078
reserved_mask:  0x8de7c3f8

CR_config:      [30]=0 (thumb exception disabled),
                [25]=0 (exception endian=little endian), 
                [20:19]=0(reset value), 

=> current_value =  bit_change(reserved_value,CR_config) = reserved_value

// arch/arm/mm/proc-v7-2level.S
v7_crval:
        crval   clear=0x2120c302, mmuset=0x10c03c7d

CR_clear:       0x2120c302
CR_mmuset:      0x10c03c7d

// arch/arm/mm/proc-v7.S
#ifdef CONFIG_SWP_EMULATE
        orr     r5, r5, #(1 << 10)              @ set SW bit in "clear"
        bic     r6, r6, #(1 << 10)              @ clear it in "mmuset"
#endif
  [10]=0, (SWP, SWPB Emulation, by CONFIG_SMP)

CR_clear:       0x2120c702
CR_mmuset:      0x10c0387d

cr=(reserved_mask & reserved_value) | (~reserved_mask & (value & ~CR_clear & CR_mmuset)
= (reserved_mask & reserved_value) | ((~reserved_mask & value) & (~reserved_mask & ~CR_clear & CR_mmuset))
((~reserved_mask & value) = 0) since value=reserved_value) 
= (reserved_mask & reserved_value) | (~reserved_mask & ~CR_clear & CR_mmuset)

(0x8de7c3f8 & 0x00c50078) | (~0x8de7c3f8 & (~0x2120c702 & 0x10c0387d))
-------------------------------------------------------
                 |       0x72183c07(=~0x8de7c3f8)
  0x8de7c3f8     |       0xdedf38fd(=~0x2120c702)
& 0x00c50078     |     & 0x10c0387d
------------     |     ------------
  0x00c50078     |       0x10003805
-------------------------------------------------------
=(0x00c50078 | 0x10003805)
=0x10c5387d



git log 8428e84d
v6이상에서는 gcc가 unaligned access 생성
aligment_init()이전에 불필요한 kernel trap을 막기 위해 CR_A clear




2-4) s2
ARM은 기본적으로 2level address translation이고 LPAE(40b addressing)를 지원하는 경우 3level address translation이다.
2lvl translation의 경우 PGD PMD PTE중 PMD를 제외하고 PGD, PTE를 사용한다.
3lvl translation의 경우 나머지 PMD를 사용하지 않고 PTE_S2를 두어 PTE를 2중으로 사용한다. (이로써 linux kernel은 최대 4level address translation을 지원하는 것으로 판단된다.)

2-6) protection_map

__P###, __S###에서 ###은 순서대로 xwr 권한이다.(chmod명령의 access permission을 상기하라)
따라서 
PROT_NONE == 000      ---
PROT_READ == 001      --r
PROT_WRITE== 010      -w-
PROT_EXEC == 100      x--
로 mapping된다.
PROT_READ | PROT_WRITE는 011이므로 __P011 또는 __S011 속성이다.


ARM(뿐만 아니라 대부분의 프로세서)의 경우 write나 execute는 read를 imply하므로
__P100==__P101, __P010==__P011, __P110==__P111
__S100==__S101, __S010==__S011, __S110==__S111


#define __PAGE_NONE             __pgprot(_L_PTE_DEFAULT | L_PTE_RDONLY | L_PTE_XN | L_PTE_NONE)
#define __PAGE_SHARED           __pgprot(_L_PTE_DEFAULT | L_PTE_USER | L_PTE_XN)
#define __PAGE_SHARED_EXEC      __pgprot(_L_PTE_DEFAULT | L_PTE_USER)
#define __PAGE_COPY             __pgprot(_L_PTE_DEFAULT | L_PTE_USER | L_PTE_RDONLY | L_PTE_XN)
#define __PAGE_COPY_EXEC        __pgprot(_L_PTE_DEFAULT | L_PTE_USER | L_PTE_RDONLY)
#define __PAGE_READONLY         __pgprot(_L_PTE_DEFAULT | L_PTE_USER | L_PTE_RDONLY | L_PTE_XN)
#define __PAGE_READONLY_EXEC    __pgprot(_L_PTE_DEFAULT | L_PTE_USER | L_PTE_RDONLY)


#define __P000  __PAGE_NONE             __pgprot(_L_PTE_DEFAULT | L_PTE_RDONLY | L_PTE_XN | L_PTE_NONE)
#define __P001  __PAGE_READONLY         __pgprot(_L_PTE_DEFAULT | L_PTE_USER | L_PTE_RDONLY | L_PTE_XN)
#define __P010  __PAGE_COPY             __pgprot(_L_PTE_DEFAULT | L_PTE_USER | L_PTE_RDONLY | L_PTE_XN)
#define __P011  __PAGE_COPY             __pgprot(_L_PTE_DEFAULT | L_PTE_USER | L_PTE_RDONLY | L_PTE_XN)
#define __P100  __PAGE_READONLY_EXEC    __pgprot(_L_PTE_DEFAULT | L_PTE_USER | L_PTE_RDONLY)
#define __P101  __PAGE_READONLY_EXEC    __pgprot(_L_PTE_DEFAULT | L_PTE_USER | L_PTE_RDONLY)
#define __P110  __PAGE_COPY_EXEC        __pgprot(_L_PTE_DEFAULT | L_PTE_USER | L_PTE_RDONLY)
#define __P111  __PAGE_COPY_EXEC        __pgprot(_L_PTE_DEFAULT | L_PTE_USER | L_PTE_RDONLY)

#define __S000  __PAGE_NONE             __pgprot(_L_PTE_DEFAULT | L_PTE_RDONLY | L_PTE_XN | L_PTE_NONE)
#define __S001  __PAGE_READONLY         __pgprot(_L_PTE_DEFAULT | L_PTE_USER | L_PTE_RDONLY | L_PTE_XN)
#define __S010  __PAGE_SHARED           __pgprot(_L_PTE_DEFAULT | L_PTE_USER | L_PTE_XN)
#define __S011  __PAGE_SHARED           __pgprot(_L_PTE_DEFAULT | L_PTE_USER | L_PTE_XN)
#define __S100  __PAGE_READONLY_EXEC    __pgprot(_L_PTE_DEFAULT | L_PTE_USER | L_PTE_RDONLY)
#define __S101  __PAGE_READONLY_EXEC    __pgprot(_L_PTE_DEFAULT | L_PTE_USER | L_PTE_RDONLY)
#define __S110  __PAGE_SHARED_EXEC      __pgprot(_L_PTE_DEFAULT | L_PTE_USER)
#define __S111  __PAGE_SHARED_EXEC      __pgprot(_L_PTE_DEFAULT | L_PTE_USER)


참고2: 

L_PTE_xxx linux page table의 attribute임을 의미한다.
PTE_xxx   hw page table
PMD_xxx   level1(section) page table 이다.









-------------------------------------------------------------------------------
20131019

local static은 지역변수중 값의 유지가 필요한 변수에 사용
done은 parse_early_param을 2회 이상 호출시 중복 수행 방지용도
tmp_cmdline는 static 선언은 thread stack과 관련되어 있다.
- stack은 thread_info와 union되어 있다.
union thread_union {
  struct thread_info thread_info;
  unsigned long stack[THREAD_SIZE/sizeof(long)];
};
- thread_info가 1kB이상으로 매우 크다.
- 현재 thread stack은 8kB이나 일부 architecture의 경우 4kB를 사용한다. (config 4KSTACKS참고)
- tmp_cmdline은 2kB이다.
non-static local variable은 stack에 잡히는데 4kB stack의 경우
여유 공간이 적어 overwrite 가능성이 있다.
따라서 static 선언으로 전역변수와 같이 bss영역 등에 잡히도록 조정한다.
해당 영역은 __initdata attribute를 통해 init 과정이후 삭제하므로 낭비되지 않는다.


__setup_start
__setup_start, __setup_end는 *(.init.setup) section의 시작과 끝에 대한 symbol이다.(vmlinux.lds참고)
.init.setup section은 __setup_param() MACRO에 의해 obs_kernel_param 구조체 형태로 생성되며
__setup_param() MACRO는 _setup() 매크로(obs_kernel_param.early=0) 혹은 early_param() 매크로(obs_kernel_param.early=1)에 의해 호출된다.
__setup(), early_param()은 커널 곳곳에 산재되어 있다.
여기서는 if조건에 따라 여러 코드중 
 early=1이면서 bootargs의 param을 str으로 저장하는 매크로 또는
 bootargs param이 console인 경우 earlycon을 str으로 저장한 매크로만
살펴본다.
1의 경우, early_param("console"... 또는 early_param("init"...) 탐색결과 존재하지 않는다.
2의 경우, console param에 대하여 __setup(ealrycon"...)을 탐색한 결과 ./drivers/tty/serial/8250/8250_early.c에 코드가 있으나 exyno의 object가 아니므로 컴파일되지 않는다. 설령 compile한다 하더라도 8250 관련 함수(setup_early_serial8250_console())에서 val이 uart, uart8250이 아닌 경우 return한다. 따라서 exynos의 경우 수행하는 작업 없이 for문을 빠져나온다.


heap sort
tree 구조를 이용하여 최소 혹은 최대값 정렬 n*log(n) 복잡도
quick sort의 경우 중간값을 잘 찾아야만 속도가 빠르나 최악의 경우 n^2 복잡도
merge sort의 경우 n*long(n)이나 다량의 메모리 공간 요구
sort는 주어진 상황에 따라 필요한 sort를 골라서 사용합니다.
참고로 random상황이 아니라 이미 sort된 상황에서 추가하는 경우 insertion sort사용
wiki 또는 java 예제 참고

http://www.eecs.wsu.edu/~cook/aa/lectures/applets/sort1/heapsort.html
http://en.wikipedia.org/wiki/Sorting_algorithm


vmalloc_min
high memory는 240MB이고 8MB는 high memory와 normal memory사이의 보호를 위한 완충지대로 생각하면 된다.
단 0xff00_0000은 high vector가 존재하는 곳이므로 이 영역을 기준으로 high memory를 설정한 것이다.


struct init
ANSI C standard를 살펴보자. C90에는 없었고 C99 표준에서 생겼다.
C99의 경우 (N1256, ISO/IEC9899:TC3)
6.7.8.7
If a designator has the form
    . identifier
then the current object (defined below) shall have structure or union type and the identifier shall be the name of a member of that type

6.7.8.34에 다음의 예가 있다.
EXAMPLE 10 Structure members can be initialized to nonzero values without depending on their order:
div_t answer = { .quot = 2, .rem = -1 };
참고1. 6.7.8.35는 더 복잡한 array 초기화에 대한 예가 있다.
EXAMPLE 11 Designators can be used to provide explicit initialization when unadorned initializer lists might be misunderstood:
struct { int a[3], b; } w[] =
{[0].a = {1}, [1].a[0] = 2 };

참고2. C99는 variable length array도 지원한다.
다음은 표준에 포함된 예이다.
#include <stddef.h>
size_t fsize3(int n)
{
char b[n+3]; // variable length array
return sizeof b; // execution time sizeof
}

참고3. 그러나 위의 코딩을 남용하지 말자.
C99를 완벽하게 지원하는 compiler가 없다 (심지어 GCC조차도...)
MS visual studio도 지원못하며 당연히 embedded 쪽은 사정이 더욱 안좋다.

개인적으로 gnu 환경이 아니라면 (예: DSP 코딩) 저런 기능이 편하고 폼도 나겠지만 지원하지 않는 compiler가 대다수이므로 기존 관습을 지키시는 것이 정신 건강에 좋아 보입니다.






__VA_ARGS__
참조: http://uuzazuk9.egloos.com/906491
ESC character
SOH -> printk안에서 log level 인식을 위한 token으로 사용
colored print예

pure
http://gcc.gnu.org/onlinedocs/gcc/Function-Attributes.html
pure: function of paramter and/or global
non-pure: feof
void function은 pure/const의 의미가 없다
      parameter/local   global
non-pure  r/w           r/w
pure      r/w          read only
const     r/w           x
CSE (Common Sub-expression Elimination)
DCE (Dead Code Elimination)
compiler
  never tack multi-threading into account (even with -pthread flag)


linker symbol
  linker script의 symbol이 맞다. 
  해당 변수는 /include/asm-generic/sections.h에 extern으로 선언되어 있으며
  compile 단계에서는 symbol table에 undefined symbol로 매핑한다. 
  undefined symbol은 linker 수행시 linker script나 다른 c 파일의 symbol table 정보와 연결하여 해당 정보를 갱신한다.

cache lookup
cache lookup은 2단계로 이루어진다.
1. index 계산 (cache way에서 해당 entry의 위치)
2. tag 비교 (index에 해당하는 여러 set에서 나머지 주소 비교

여기서 VA->PA 전환이 가능한 3가지 지점에 따라 PIPT, VIPT, VIVT로 나누어진다.
    |-------------------|-------------------|
    |     index 연산    |    tag비교        |
    1                   2                   3
    PIPT              PIVT                VIVT
VA<--------------------------------------------->PA

1(PIPT): index도 비교하기전에 VA->PA변환이 이루어진다.
  따라서 index, tag모두 PA기준으로 동작한다.
  Physically Indexed, Physically Tagged

2(VIPT): index 연산 이후 VA->PA로 변환된다.
  따라서 index 연산까지는 VA로 tag비교는 PA로 동작한다.
  Virtually Indexed, Physically Tagged

3(VIVT): 모든 cache lookup 이후 VA->PA로 변환된다.
  따라서 index 연산과 tag비교 모두 VA로 동작한다.
  Virtually Indexed, Virtually Tagged

여기서 aliasing 문제를 생각해보자
VA      PA
0x1000-0x2000
0x3000/
현재 위와 같이 서로다른 VA가 동일한 PA에 매핑되는 경우라 하자
P1 태스크가 초기화후 P2태스크가 update하기를 기다리는 다음의 코드가 있다.
P1: write(0x1000, 0x1111);
P2: write(0x3000, 0x2222);
P1: repeat until read(0x1000) = 0x1111;

PIPT의 경우: 0x3000, 0x1000모두 0x2000으로 바뀐 후 cache에 적재
  aliasing문제 없다.

VIVT의 경우 cache에 0x1000, 0x3000번지가 동시에 들어가 있을 가능성이 있다.
이경우 cache에서 서로 다른 entry을 write하므로 P1은 P2의 write를 볼 수 없다.

VIPT의 경우 2가지 경우가 있다.
1. 4 way 16kB cache의 경우: 즉 1 way가 4kB. 
  4kB는 page frame 단위로 그 범위 안에서는 PA=VA이다.
  즉 virtual index와 Physical index가 동일하므로 PIPT와 동일하게 동작한다.
2. 4 way 32kB cache의 경우: 1 way가 8kB
  1과 달리 MMU에 의해 index가 바뀐다. VIVT와 마찬가지로 aliasing 가능성 존재

aliasing 문제를 풀기위해서는 PIPT가 좋다. 나머지의 경우 SW관리가 필요하다.
그런데 PIPT의 경우 latency문제가 있다.
pipeline stall등을 벌기 위해 cache를 도입하고 그중에서도 더 속도를 빠르게 하기 위해 작은 size의 L1 cache를 도입했는데 TLB lookup 시간을 허비하는 것이다.
1. 일반적인 2 level 혹은 3 level descriptor의 경우 2단게 혹은 3단계의 lookup을 반복
2. TLB hite rate
1A.은 보통 최종단계의 translation 결과를 저장하여 해결한다.
2A.TLB miss의 경우 memory read로 인해 latency가 길어지므로 TLB의 크기를 늘려 hit rate를 증가

1A는 2A의 필요성을 더 크게 한다.
문제는 물리적인 제약상 메모리는 크기가 클수록 접근시간이 느려진다는 점이다.

이를 극복하기 위해 L2상위에 L1 캐시를 도입한 것 처럼 uTLB를 도입하여 latency를 최소화한다.


